package vt.posets.main;

import java.util.ArrayList;
import java.util.List;

import vt.posets.poset.Poset;

/**
 * Class used to run experiments from static methods on Poset Algorithms contained in the PosetAlgorithms class.
 * 
 * @author Ethan Gaebel (egaebel)
 *
 */
public class DataGathering {

	
	/**
	 * This program runs data gathering methods for the generatingPosetOne, generatingPosetTwo, and generatingKitePosetCover algorithms.
	 * Each algorithm operates on randomly generated data that matches the parameters specified by the arguments passed to the algorithm. 
	 * These arguments are explained below.
	 * 
	 * FLAGS:::::::::::::::::::::::::::::::::::::::::::::::::::
	 * @param -all -- Runs all of the algorithms with timings
	 * @param -one -- Runs the generatingPosetOne algorithm.
	 * @param -two -- Runs the generatingPosetTwo algorithm.
	 * @param -kite -- Runs the generatingKitePosetCover algorithm
	 * 
	 * ARGUMENTS:::::::::::::::::::::::::::::::::::::::::::::::
	 * @param numberOfStartingElements the number of elements in the starting set. (REQUIRED FOR ALL)
	 * @param numberOfEndingElements the number of elements in the ending set. (REQUIRED FOR ALL)
	 * @param numPosets the number of Posets to run each trial on. (REQUIRED FOR ALL)
	 * @param maxStartingNodes the maximum number of source nodes for a poset. (REQUIRED FOR ONE, TWO, AND ALL FLAGS)
	 * @param maxEndingNodes the maximum number of sink nodes for a poset. (REQUIRED FOR ONE, TWO, AND ALL FLAGS)
	 * @param prTime integer field specifying whether the Pruesse & Ruskey algorithm should be timed. (ONLY USEFUL FOR ONE AND TWO)
	 * 			0 indicates that the algorithm should not be timed, 
	 * 			1 indicates it should be. (NOT REQUIRED, DEFAULTS TO 0).
	 * @param minKiteSize the smallest size of a kite. This argument's behavior differs depending on the varyKiteSize argument below. (ONLY USEFUL FOR KITE) (REQUIRED FOR KITE)
	 * @param maxKiteSize the largest size of a kite. This argument's behavior differs depending on the varyKiteSize argument below. (ONLY USEFUL FOR KITE) (NOT REQUIRED FOR KITE UNLESS varyKiteSize == 1)
	 * @param useProbability integer field specifying whether kite posets generated should be generated using probabilities. (ONLY USEFUL FOR KITE)
	 * 			0 indicates that the Posets should be generated without using probability
	 * 			1 indicates that the Posets should be generated by always making kites when not in kites. (NOT REQUIRED, DEFAULTS TO 1).
	 * @param varyKiteSize integer field specifying whether kite posets should be generated by varying size or should always be of size minKiteSize (ONLY USEFUL FOR KITE)
	 * 			0 indicates that the posets should always be of size minKiteSize
	 * 			1 indicates that the posets should vary in size between minKiteSize and maxKiteSize. (NOT REQUIRED, DEFAULTS TO 0)
	 */
	public static void main(String [] args) {

		if (args.length == 0) {
			
			
		}
		else {
			
			//
			for (int i = 0; i < args.length; i++) {
				
				
			}
		}
		
		//Large data set for algorithm 2
		System.out.println("############################################################################################################################################");
		runGeneratingPosetAlgorithmTwo(5, 17, 100, 3, 3, false);
		
		//Large data set for algorithms 1 & 2
		System.out.println("Large data set for algorithms 1 & 2");
		System.out.println("############################################################################################################################################");
		runGeneratingPosetAlgorithmOneAndTwo(3, 17, 100, 3, 3, false);
		
		//Large set of start/end vertices for algorithm 1
		System.out.println("############################################################################################################################################");
		runGeneratingPosetAlgorithmOne(3, 10, 100, 7, 7, false);
		
		//Large set of start/end vertices for algorithm 2
		System.out.println("############################################################################################################################################");
		runGeneratingPosetAlgorithmTwo(3, 10, 100, 7, 7, false);
		
		//Large set of start/end vertices for algorithms 1 & 2
		System.out.println("############################################################################################################################################");
		System.out.println("Large set of start/end vertices for algorithms 1 & 2");
		runGeneratingPosetAlgorithmOneAndTwo(3, 10, 100, 7, 7, false);
		
		//Large number of elements for memory profiling on algorithm 2
		System.out.println("############################################################################################################################################");
		runGeneratingPosetAlgorithmTwo(17, 18, 100, 3, 3, false);
		
		//Large range of elements for Kite Poset Cover, randomly make kites
		System.out.println("############################################################################################################################################");
		runGeneratingKitePosetCoverAlgorithm(4, 18, 100, 2, 2, true, false);
		
		System.out.println("DONE!");
	}

	//~Methods-------------------------------------------------
	/**
	 * Runs both the generatingPosetOneAlgorithm and the generatingPosetTwoAlgorithm and times their runs. 
	 * The starting size of the poset, the number of runs, and the type of poset (# of starting and ending nodes)
	 * is determined by the passed elements.
	 * 
	 * @param startingElements the number of elements in the set to start with.
	 * @param finishingElements the number of elements in the set at the end of the run.
	 * @param numPosets the number of posets to generate for each run.
	 * @param maxStartingNodes the maximum number of starting nodes (the count starts at 1 and goes up to this number).
	 * @param maxEndingNodes the maximum number of ending nodes (the count starts at 1 and goes up to this number).
	 * @param prTime boolean flag, if true the Pruesse & Ruskey algorithm will be timed, if false it will not be.
	 * 
	 * output format:
	 * RunningGeneratingPosetAlgorithm-One with <#elements> elements.
	 * RunningAlgorithm with Posets with <#startingNodes> starting nodes and <#endingNodes> ending nodes
	 * <Time for PR>  (IF prTime == true)
	 * <Time for Algorithm 1>
	 * <Time for PR>  (IF prTime == true)
	 * <Time for Algorithm 2>
	 */
	public static void runGeneratingPosetAlgorithmOneAndTwo(int startingElements, int finishingElements, int numPosets, int maxStartingNodes, int maxEndingNodes, boolean prTime) {
		
		List<Integer> elements = new ArrayList<Integer>();
		int k = 1;
		//Initial additions to elements
		for (; k <= startingElements; k++) {
			elements.add(k);
		}

		for (; k <= finishingElements + 1; k++) {
			System.out.println("Running GeneratingPosetAlgorithm-One & -Two with " + (k - 1) + " elements.");
			for (int i = 1; i <= maxStartingNodes; i++) {
				for (int j = 1; j <= maxEndingNodes; j++) {
					
					List<Poset<Integer>> posets = generateRandomPosetsAdjustment(elements, numPosets, i, j);
					if (posets != null) { 
					
						List<Long> timings1 = new ArrayList<>(numPosets);
						long poset1AvgTiming;
						List<Long> timings2 = new ArrayList<>(numPosets);
						long poset2AvgTiming;
						
						System.out.println("Running Algorithm with Posets with " + i + " starting nodes and " + j + " ending nodes");
						for (Poset<Integer> poset : posets) {
							
							ArrayList<ArrayList<String>> parsedLinearOrders = PosetAlgorithms.runPruesseRuskey(poset, elements.size(), "DataCollectionOnAlgorithmTwo");
							ArrayList<ArrayList<Integer>> linearOrders = PosetAlgorithms.parsedPruesseRuskeyToInteger(parsedLinearOrders);
							
							//~ALGORITHM ONE--------------------------------------------------------------------------------
							//System.out.println("Running Algorithm One");
							long begTime = System.currentTimeMillis();
							Poset<Integer> generatedPoset1 = PosetAlgorithms.generatingPosetOne(linearOrders, prTime);
							long endTime = System.currentTimeMillis();
							timings1.add(endTime - begTime);
							
							//Check for success
							if (generatedPoset1 == null) {
								System.out.println("With Algorithm One the Poset generation failed!!!!");
								try {
									
									Thread.sleep(1);
									//System.exit(1);
									continue;
								} 
								catch (InterruptedException e) {
									e.printStackTrace();
								}
							}
							else {
								
								//System.out.println("Success with Algorithm One");
							}
							
							//~ALGORITHM TWO--------------------------------------------------------------------------------
							//System.out.println("Running Algorithm Two");
							begTime = System.currentTimeMillis();
							Poset<Integer> generatedPoset2 = PosetAlgorithms.generatingPosetTwo(linearOrders, prTime, false);
							endTime = System.currentTimeMillis();
							timings2.add(endTime - begTime);
							
							//Check for success
							if (generatedPoset2 == null) {
								System.out.println("With Algorithm Two the Poset generation failed!!!!");
								try {
									Thread.sleep(1);
									//System.exit(1);
									continue;
								} 
								catch (InterruptedException e) {
									e.printStackTrace();
								}
							}
							else {
								
								//System.out.println("Success with Algorithm Two");
							}
							
							//Check if the generated Posets are the same
							if (!generatedPoset1.equals(generatedPoset2)) {
								System.out.println("\n\nIT DOESN'T WORK\n\n");
								try {
									Thread.sleep(10000);
									System.exit(1);
								} catch (InterruptedException e) {
									e.printStackTrace();
								}
							}
						}
						
						//Calculate Average timeS
						//First poset algorithm
						poset1AvgTiming = 0;
						for (int p = 0; p < timings1.size(); p++) {
						
							poset1AvgTiming += timings1.get(p);
						}
						poset1AvgTiming /= timings1.size();
						
						//Print
						System.out.println(poset1AvgTiming);
						
						//Second poset algorithm
						poset2AvgTiming = 0;
						for (int p = 0; p < timings2.size(); p++) {
							
							poset2AvgTiming += timings2.get(p);
						}
						poset2AvgTiming /= timings2.size();
						
						//Print
						System.out.println(poset2AvgTiming);
					}
					else {
						
						System.out.println("POSETS NULL");
					}
				}
			}
			elements.add(k);
		}
	}
	
	/**
	 * Runs the generatingPosetOneAlgorithm and times its run. 
	 * The starting size of the poset, the number of runs, and the type of poset (# of starting and ending nodes)
	 * is determined by the passed elements.
	 * 
	 * @param startingElements the number of elements in the set to start with.
	 * @param finishingElements the number of elements in the set at the end of the run.
	 * @param numPosets the number of posets to generate for each run.
	 * @param maxStartingNodes the maximum number of starting nodes (the count starts at 1 and goes up to this number).
	 * @param maxEndingNodes the maximum number of ending nodes (the count starts at 1 and goes up to this number).
	 * @param prTime boolean flag, if true the time to run the pr algorithm is printed out, if false it is not printed.
	 */
	public static void runGeneratingPosetAlgorithmOne(int startingElements, int finishingElements, int numPosets, int maxStartingNodes, int maxEndingNodes, boolean prTime) {
		
		List<Integer> elements = new ArrayList<Integer>();
		int k = 1;
		//Initial additions to elements
		for (; k <= startingElements; k++) {
			elements.add(k);
		}

		for (; k <= finishingElements + 1; k++) {
			System.out.println("Running GeneratingPosetAlgorithmOne with " + (k - 1) + " elements.");
			for (int i = 1; i <= maxStartingNodes; i++) {
				for (int j = 1; j <= maxEndingNodes; j++) {
					
					List<Poset<Integer>> posets = generateRandomPosetsAdjustment(elements, numPosets, i, j);
					if (posets != null) { 
					
						List<Long> timings = new ArrayList<>(numPosets);
						long avgTiming;
						
						System.out.println("Running Algorithm with Posets with " + i + " starting nodes and " + j + " ending nodes");
						for (Poset<Integer> poset : posets) {
							
							ArrayList<ArrayList<String>> parsedLinearOrders = PosetAlgorithms.runPruesseRuskey(poset, elements.size(), "DataCollectionOnAlgorithmTwo");
							ArrayList<ArrayList<Integer>> linearOrders = PosetAlgorithms.parsedPruesseRuskeyToInteger(parsedLinearOrders);
							
							long begTime = System.currentTimeMillis();
							Poset<Integer> generatedPoset = PosetAlgorithms.generatingPosetOne(linearOrders, prTime);
							long endTime = System.currentTimeMillis();
							
							timings.add((endTime - begTime));
							
							if (generatedPoset == null) {
								System.out.println("The Poset generation failed!!!!");
								try {
									Thread.sleep(1);
									//System.exit(1);
									continue;
								} 
								catch (InterruptedException e) {
									e.printStackTrace();
								}
							}
						}
						
						//Calculate Average time
						avgTiming = 0;
						for (int p = 0; p < timings.size(); p++) {
						
							avgTiming += timings.get(p);
						}
						avgTiming /= timings.size();
						//Print
						System.out.println(avgTiming);
					}
					else {
						
						System.out.println("POSETS NULL");
					}
				}
			}
			elements.add(k);
		}
	}
	
	/**
	 * Runs the generatingPosetTwoAlgorithm and times its run. 
	 * The starting size of the poset, the number of runs, and the type of poset (# of starting and ending nodes)
	 * is determined by the passed elements.
	 * 
	 * @param startingElements the number of elements in the set to start with.
	 * @param finishingElements the number of elements in the set at the end of the run.
	 * @param numPosets the number of posets to generate for each run.
	 * @param maxStartingNodes the maximum number of starting nodes (the count starts at 1 and goes up to this number).
	 * @param maxEndingNodes the maximum number of ending nodes (the count starts at 1 and goes up to this number).
	 * @param prTime boolean flag, if true the time to run the pr algorithm is printed out, if false it is not printed.
	 */
	public static void runGeneratingPosetAlgorithmTwo(int startingElements, int finishingElements, int numPosets, int maxStartingNodes, int maxEndingNodes, boolean prTime) {
		
		List<Integer> elements = new ArrayList<Integer>();
		int k = 1;
		//Initial additions to elements
		for (; k <= startingElements; k++) {
			elements.add(k);
		}

		for (; k <= finishingElements + 1; k++) {
			System.out.println("Running GeneratingPosetAlgorithmTwo with " + (k - 1) + " elements.");
			for (int i = 1; i <= maxStartingNodes; i++) {
				for (int j = 1; j <= maxEndingNodes; j++) {
			
					List<Long> timings = new ArrayList<>(numPosets);
					long avgTiming;
					
					List<Poset<Integer>> posets = generateRandomPosetsAdjustment(elements, numPosets, i, j);
					if (posets != null) { 
					
						System.out.println("Running Algorithm with Posets with " + i + " starting nodes and " + j + " ending nodes");
						for (Poset<Integer> poset : posets) {
System.out.println("yada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yadyada yada yada");
System.out.println("test poset is...................\n" + poset.toString() + "\n....................................");
System.out.println("with cover edges: \n" + poset.printCoverEdges() + "\n...................................................\n\n");
							ArrayList<ArrayList<String>> parsedLinearOrders = PosetAlgorithms.runPruesseRuskey(poset, elements.size(), "DataCollectionOnAlgorithmTwo");
							ArrayList<ArrayList<Integer>> linearOrders = poset.applyMapping(parsedLinearOrders);
							//ArrayList<ArrayList<Integer>> linearOrders = PosetAlgorithms.parsedPruesseRuskeyToInteger(parsedLinearOrders);
							
							long begTime = System.currentTimeMillis();
							Poset<Integer> generatedPoset = PosetAlgorithms.generatingPosetTwo(linearOrders, prTime, false);
							long endTime = System.currentTimeMillis();
							
							timings.add((endTime - begTime));
							
							if (generatedPoset == null) {
								System.out.println("The Poset generation failed!!!!");
								try {
									Thread.sleep(1);
									//System.exit(1);
									continue;
								} 
								catch (InterruptedException e) {
									e.printStackTrace();
								}
							}
						}
						
						//Calculate Average time
						avgTiming = 0;
						for (int p = 0; p < timings.size(); p++) {
						
							avgTiming += timings.get(p);
						}
						avgTiming /= timings.size();
						//Print
						System.out.println(avgTiming);
					}
					else {
						
						System.out.println("POSETS NULL");
					}
				}
			}
			elements.add(k);
		}
	}
	
	/**
	 * Static method used to time the generatingKitePosetCover method in the PosetAlgorithm class. Runs numPosets times and takes
	 * the average of the run times. This process is repeated for startingElements sized sets up to finishingElements sized sets.
	 * 
	 * @param startingElements the number of elements to run on first.
	 * @param finishingElements the number of elements to run on last.
	 * @param numPosets the number of posets to run on each time.
	 * @param minKiteSize the smallest kite that can occur. This value should be >= 2. 
	 * 			NOTE: This value's significance changes depending on the varyKiteSize field.
	 * @param maxKiteSize the largest kite size that can occur. This value should be >= minKiteSize >= 2.
	 * 			NOTE: This value's significance changes depending on the varyKiteSize field.
	 * @param useProbability boolean flag, true indicates that Kite posets should be generated using probabilities to determine their occurrence,
	 * 			false indicates that kites should be created whenever possible.
	 * @param varyKiteSize boolean flag, true indicates that the kite size should vary between minKiteSize and maxKiteSize,
	 * 			false indicates that the kite size should always be equal to minKiteSize.
	 */
	public static void runGeneratingKitePosetCoverAlgorithm(int startingElements, int finishingElements, int numPosets, int minKiteSize, int maxKiteSize, boolean useProbability, boolean varyKiteSize) {
	
		List<Integer> elements = new ArrayList<Integer>();
		int k = 1;
		//Initial additions to elements
		for (; k <= startingElements; k++) {
			elements.add(k);
		}

		for (; k <= finishingElements + 1; k++) {
			System.out.println("Running GeneratingPosetAlgorithmTwo with " + (k - 1) + " elements.");
			
			List<Long> timings = new ArrayList<>(numPosets);
			long avgTiming;
			List<Poset<Integer>> posets = PosetAlgorithms.generateKitePosets(elements, numPosets, minKiteSize, maxKiteSize, false, false);
			if (posets != null) { 
			
				System.out.println("Running Algorithm with Posets having 2-Kites");
				for (Poset<Integer> poset : posets) {
					
					ArrayList<ArrayList<String>> parsedLinearOrders = PosetAlgorithms.runPruesseRuskey(poset, elements.size(), "DataCollectionOnKitePosetCoverAlgorithm");
					ArrayList<ArrayList<Integer>> linearOrders = PosetAlgorithms.parsedPruesseRuskeyToInteger(parsedLinearOrders);
					
					long begTime = System.currentTimeMillis();
					@SuppressWarnings("unused")
					List<Poset<Integer>> generatedPosets = PosetAlgorithms.generatingKitePosetCover(linearOrders);
					long endTime = System.currentTimeMillis();
					
					timings.add((endTime - begTime));
				}
				
				//Calculate Average time
				avgTiming = 0;
				for (int p = 0; p < timings.size(); p++) {
				
					avgTiming += timings.get(p);
				}
				avgTiming /= timings.size();
				//Print
				System.out.println(avgTiming);
			}
			else {
				
				System.out.println("POSETS NULL");
			}
			
			elements.add(k);
		}
	}
	
	/**
	 * Takes a List<Integer> of elements and creates numPosets Posets with startVertices starting vertices of the poset and endVertices
	 * ending vertices of the poset.
	 * 
	 * @param elements the set to create the posets from.
	 * @param numPosets the number of posets to generate.
	 * @param startVertices the number of vertices in the posets that should be started with.
	 * @param endVertices the number of vertices in the posets that should be ended with.
	 * @return a List<Poset<Integer>> containing the randomly generated posets.
	 */
	private static List<Poset<Integer>> generateRandomPosetsAdjustment (List<Integer> elements, int numPosets, int startVertices, int endVertices) {
		
		long begTime = System.currentTimeMillis();
		long TIMEOUT_TIME = 1000000;
		
		List<Poset<Integer>> posets = PosetAlgorithms.generateRandomPosets(elements, numPosets, startVertices, endVertices);

		if (System.currentTimeMillis() - begTime > TIMEOUT_TIME) {
			System.out.println("TIMEOUT IN CREATING RANDOM POSETS");
			return null;
		}

		return posets;
	}
}