package vt.posets.main;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;

import vt.posets.graph.AdjacencyMatrix;
import vt.posets.graph.Edge;
import vt.posets.matching.LinearOrderVertex;
import vt.posets.matching.MyEdmondsMatching;
import vt.posets.matching.PosetEdge;
import vt.posets.poset.ClosureEdge;
import vt.posets.poset.CoverEdge;
import vt.posets.poset.Poset;

/**
 * A class containing poset algorithms.
 * 
 * @author Ethan Gaebel (egaebel)
 *
 * @param <T>
 */
public class PosetAlgorithms<T extends Comparable<T>> {

	//~Constants----------------------------------------------

	//~Data Fields--------------------------------------------

	//~Constructors--------------------------------------------

	//~Methods-------------------------------------------------
	/**
	 * Takes a list of elements and a number specifying the number of desired posets.
	 * Then, generates <num> posets which contain the elements contained in elements.
	 * The posets are generated by adding edges between the elements with probability p
	 * and then removing edges until the poset is a dag. Then the transitive closure is taken.
	 * 
	 * @param elements the elements used to construc the posets.
	 * @param num the quantity of posets to generate.
	 * @return the generated posets.
	 */
	public static <T extends Comparable<T>> List<Poset<T>> generateRandomPosetsFromDag(List<T> elements, int num) {
		
		List<Poset<T>> posets = new ArrayList<Poset<T>>();
		Random rand = new Random();
		
		Poset<T> poset;
		for (int i = 0; i < num; i++) {
			
			poset = new Poset<T>(elements);
			//Add edges with probability 0.25
			for (int j = 0; j < elements.size(); j++) {
			
				for (int k = 0; k < elements.size(); k++) {
					
					if (rand.nextInt() % 4 == 2) {
						
						poset.addEdge(j, k);
					}
				}
			}
			
			//Remove edges in the order to make a dag
			for (int p = 0; p < elements.size(); p++) {
				
				for (int m = p + 1; m < elements.size(); m++) {
					
					poset.removeEdge(m, p);
				}
			}
			
			//Take transitive closure
			poset = poset.transitiveClosure();
			
			//Add poset to set
			posets.add(poset);
		}
		
		return posets;
	}
	
	/**
	 * Generates a set of numPosets random posets by taking a List of elements and iterating over each pair elements, 
	 * randomly adding an edge between two elements, and then taking the transitive closure of the resultant poset. 
	 * This method takes several parameters specifying the characteristics of the generated posets. Namely, startNodes and endNodes.
	 * 
	 * @param elements the elements to include in the Poset.
	 * @param numPosets the number of posets to generate.
	 * @param startNodes the number of nodes that can serve as sources for the poset.
	 * @param endNodes the number of nodes that can serve as sinks for the poset.
	 * @return
	 */
	public static <T extends Comparable<T>> List<Poset<T>> generateRandomPosets(List<T> elements, int numPosets, int startNodes, int endNodes) {
	
		Random rand = new Random();	
		
		//Construct the LinearOrder
		List<Poset<T>> posets = new ArrayList<Poset<T>>();
		Poset<T> poset;
		while (posets.size() < numPosets) {
			poset = new Poset<T>(elements, elements.size());
			//Make Random Poset
			for (int i = 0; i < elements.size(); i++) {

				for (int j = i; j < elements.size(); j++) {
					
					if (i == j) {
					
						poset.addClosureEdge(i, j);
					}
					else if (rand.nextBoolean()) {
						
						poset.addEdge(i, j);
					}	
				}
			}
			
			//Take transitive Closure
			poset = poset.transitiveClosure();
					
			//Verify that Random Poset is valid (that is, the graph is connected)
			boolean validPoset = true;
			int numStartNodes = 0;
			int numEndNodes = 0;
			for (T vertex : poset.getVertices()) {
				
				List<T> edgesTo = poset.getEdgesTo(vertex);
				List<T> edgesFrom = poset.getEdgesFrom(vertex);
				//If the only edge is to itself and it is the second case of this happening, INVALID
				if (edgesTo.size() == 1 && edgesFrom.size() == 1 
						&& edgesTo.get(0).equals(vertex) && edgesFrom.get(0).equals(vertex)) {
					
					validPoset = false;
					break;
				}
				
				//~Filtration by Parameterization------------------------
				//vertex is a start node.
				if (edgesFrom.size() == 1 && edgesFrom.get(0).equals(vertex)) {
					
					numStartNodes++;
					if (numStartNodes > startNodes) {
						validPoset = false;
						break;
					}
				}
				
				//vertex is an end node.
				if (edgesTo.size() == 1 && edgesTo.get(0).equals(vertex)) {
					
					numEndNodes++;
					if (numEndNodes > endNodes) {
						validPoset = false;
						break;
					}
				}
			}
poset = poset.transitiveReduction();
poset = poset.transitiveClosure();
			//Add Poset if it is valid
			if (validPoset) {
				posets.add(poset);
			}
		}
		
		return posets;
	}
	
	/**
	 * Generates a List of Kite Posets that have kites of minimum size minKiteSize and a maximum size of maxKiteSize.
	 * Does so by iterating over each element and if the element is not currently part of a kite it splits off into a kite,
	 * either by probability or with certainty, depending on the flag useProbability.
	 * 
	 * @param elements the elements used to construct the Posets.
	 * @param num the quantity of Posets to generate.
	 * @param minKiteSize the minimum size of the kites. 
	 * 			If varyKiteSize is false, this is always the size of the kites. 
	 * @param maxKiteSize the maximum size of the kites.
	 * @param useProbability boolean flag specifying whether to split into a Kite by probability or certainty.
	 * @param varyKiteSize boolean flag specifying whether to set each kite size to some number between minKiteSize and maxKiteSize
	 * 			or to set it to minKiteSize. If true, it is between minKiteSize and maxKiteSize, if false all kites are of size minKiteSize.
	 * @return the generated Posets.
	 */
	public static <T> List<Poset<T>> generateKitePosets(List<T> elements, int num, int minKiteSize, int maxKiteSize, boolean useProbability, boolean varyKiteSize) {
		
		List<Poset<T>> posets = new ArrayList<Poset<T>>();
		Random rand = new Random();
		
		//Make num Posets
		for (int k = 0; k < num; k++) {

			boolean inKite = false;
			int kiteSize = -1;
			int prevIndex = -1;
			int kiteCloseIndex = -1;
			Poset<T> p = new Poset<T>(elements, elements.size());
			
			//Iterate over all elements
			for (int i = 0; i < elements.size(); i++) {
				
				//If NOT currently in a kite
				if (!inKite) {
				
					//Add edge
					if (prevIndex != -1) {
						
						p.addEdge(prevIndex, i);
					}
					
					//Enter a Kite with either probability or not probability
					if ((useProbability && rand.nextBoolean()) || !useProbability) {
					
						inKite = true;
						kiteSize = varyKiteSize ? ((rand.nextInt() + minKiteSize) % maxKiteSize) : minKiteSize;
						
						kiteCloseIndex = i + kiteSize + 1;
					}
					prevIndex = i;
				}
				//In a kite
				else {
					
					p.addEdge(prevIndex, i);
					p.addEdge(i, kiteCloseIndex);
					
					kiteSize--;
					if (kiteSize == 0) {
						
						inKite = false;
						i++;
						prevIndex = i;
					}
				}
			}

			p = p.transitiveClosure();

			posets.add(p);
		}
		
		return posets;
	}
	
	/**
	 * Algorithm that takes in a List of a List of elements of type T.
	 * Each List<T> contained in the List represents a linear order.
	 * The order of the T typed elements in the Lists is the order of the 
	 * elements in the linear order.
	 * 
	 *  @param linearOrders a List of ArrayLists that hold elements of type T. 
	 *  		The order of the ArrayLists is the order of the LinearOrder.
	 *  @param timePruesseRuskey boolean flag, if true the pruesse ruskey algorithm 
	 *  		being run for verification will be timed and have its time outputted.
	 *  @return a poset generated from the passed in linearOrders.
	 *  
	 *  Big O analysis:
	 *  m = linearOrders.size()
	 *  n = linearOrders.get(0).size() (since all linear orders are the same length)
	 */
	public static <T extends Comparable<T>> Poset<T> generatingPosetOne(List<ArrayList<T>> linearOrders, boolean timePruesseRuskey) {
		
		//Ensure there actually are linear orders
		if (linearOrders.size() > 0) {
			
			ClosureEdge<T> edge;
			Poset<T> p = new Poset<T>(linearOrders.get(0).size());
			Iterator<ArrayList<T>> orderIt = linearOrders.iterator();
			HashMap<T, Integer> vertexMap = new HashMap<T, Integer>();
			HashSet<EdgeIndexWrapper<T>> edgeSet = new HashSet<EdgeIndexWrapper<T>>();
			HashSet<EdgeIndexWrapper<T>> finalEdgeSet = new HashSet<EdgeIndexWrapper<T>>();
			
			//Iterate over the linear orders
			//O(m)
			//Total: O(2mn^2)
			int k = 0;
			while(orderIt.hasNext()) {

				ArrayList<T> linearOrder = orderIt.next();

				//O(n)
				//Total: O(n^2)
				for (int i = 0; i < linearOrder.size(); i++) {
	
					//O(n) - i
					for (int j = i; j < linearOrder.size(); j++) {
	
						//If on first run, add vertices to poset
						if (i == 0 && k == 0) {
							
							p.addVertex(linearOrder.get(j));
							vertexMap.put(linearOrder.get(j), j);
						}

						//If the vertices are adjacent, then add a Cover Edge
						if (i + 1 == j) {

							edge = new CoverEdge<T>(1, linearOrder.get(i), linearOrder.get(j));
						}
						//Non-adjacent, add a Closure Edge
						else {

							edge = new ClosureEdge<T>(1, linearOrder.get(i), linearOrder.get(j));
						}

						edgeSet.add(new EdgeIndexWrapper<T>(vertexMap.get(linearOrder.get(i)), vertexMap.get(linearOrder.get(j)), edge));
					}
				}
				
				//O(n)
				//If first run, add whole set
				if (finalEdgeSet.isEmpty()) {
				
					finalEdgeSet.addAll(edgeSet);
				}
				else {

					//Essentially the retainAll operation on sets, except CoverEdges are taken in favor of ClosureEdges
					Iterator<EdgeIndexWrapper<T>> it = edgeSet.iterator();
					while (it.hasNext()) {
						
						EdgeIndexWrapper<T> element = it.next();

						//Check for containment and remove if not
						if (!finalEdgeSet.contains(element)) {

							finalEdgeSet.remove(element);
						}
						//convert ClosureEdge to CoverEdge if one is found
						else if (element.getEdge() instanceof CoverEdge<?>) {

							finalEdgeSet.remove(element);				
							finalEdgeSet.add(element);
						}
						
					}
					it = finalEdgeSet.iterator();
					while(it.hasNext()) {
						
						EdgeIndexWrapper<T> element = it.next();
						
						if (!edgeSet.contains(element)) {
							
							it.remove();
						}
					}
				}

				edgeSet = new HashSet<EdgeIndexWrapper<T>>();
				k++;
			}
						

			//Add the intersection of edges to the poset
			Iterator<EdgeIndexWrapper<T>> edgeIt = finalEdgeSet.iterator();
			EdgeIndexWrapper<T> wrap;
			//O(n^2) (worst case)
			while (edgeIt.hasNext()) {
				
				wrap = edgeIt.next();
				edge = wrap.getEdge();
				if (edge instanceof CoverEdge<?>) {
					
					p.addEdge(wrap.getFromIndex(), wrap.getToIndex(), edge);
				}
				else {					
					
					p.addClosureEdge(wrap.getFromIndex(), wrap.getToIndex(), edge);
				}
			}

			//Verify with Pruesse & Ruskey Algorithm
			//Both options below perform the same action, the first one simply times and prints the time of the Pruesse & Ruskey Algorithm
			if (timePruesseRuskey) {
				
				long begTime = System.currentTimeMillis();
				if (prLinearExtensionsCheck(linearOrders, p, false)) {
					
					long endTime = System.currentTimeMillis();
					System.out.println("Pruesse & Ruskey time == " + (endTime - begTime));
					
					return p;
				}
			}
			else {
				
				if (prLinearExtensionsCheck(linearOrders, p, false)) {
					
					return p;
				}
			}
		}
		
		return null;
	}
	
	/**
	 * Algorithm that takes in a List of a List of elements of type T.
	 * Each List<T> contained in the List represents a linear order.
	 * The order of the T typed elements in the Lists is the order of the 
	 * elements in the linear order.
	 * 
	 *  @param linearOrders a List of ArrayLists that hold elements of type T. 
	 *  		The order of the ArrayLists is the order of the LinearOrder.
	 * @param suppressErrors boolean falg indicating whether to suppressError output to stdout. 
	 * 			True to suppress the output, false to output it to stdout.
	 */
	public static <T extends Comparable<T>> Poset<T> generatingPosetTwo(List<ArrayList<T>> linearOrders, boolean timePruesseRuskey, boolean suppressErrors) {

		Poset<T> p;
		
		Iterator<ArrayList<T>> it = linearOrders.iterator();
		if (it.hasNext()) {
		
			p = new Poset<T>(it.next());
			p = p.transitiveClosure();
		}
		else {
			
			return null;
		}
System.out.println("initial Poset p == \n" + p.toString());
System.out.println("with cover edges == \n" + p.printCoverEdges());
		//Iterate over all Linear Orders passed in
		while(it.hasNext()) {

			List<T> linearOrder = it.next();
			Poset<T> tempPoset = new Poset<T>(linearOrder);

			for (CoverEdge<T> edge : tempPoset.getCoverEdges()) {

				//If inverse edge is present, it must be removed
				if (p.hasClosureEdge(edge.getTo(), edge.getFrom()) 
						|| p.hasEdge(edge.getTo(), edge.getFrom())) {
System.out.println("removing edge at indices... " + p.getIndexOf(edge.getTo()) + ",,,, " + p.getIndexOf(edge.getFrom()));
					p.removeEdge(edge.getTo(), edge.getFrom());
				}
				
				//If edge is present but is not cover edge, swap it out
				if (p.hasClosureEdge(edge.getFrom(), edge.getTo())) {
					
					p.swapEdgeToCover(edge.getFrom(), edge.getTo());
System.out.println("SWAPPPPINGG edge at indices... " + p.getIndexOf(edge.getFrom()) + ",,,, " + p.getIndexOf(edge.getTo()));
				}
			}
		}
p = p.transitiveReduction();
p = p.transitiveClosure();
		//The below statements do the same things, 
		//the first one simply times the Pruesse & Ruskey algorithm and prints its time
		if (timePruesseRuskey) {
			
			long begTime = System.currentTimeMillis();
			//Check gamma against linear extensions
			if (prLinearExtensionsCheck(linearOrders, p, suppressErrors)) {
				
				long endTime = System.currentTimeMillis();
				System.out.println("Pruesse & Ruskey Time == " + (endTime - begTime));
				return p;
			}
			
		}
		else {
System.out.println("LINEAR ORDERS PASSED TO GENERATING POSET TWO%^%^%^%^%^%^%^%^%^&%^&%^&%^&%&%^&%^&%^&%&^%&^&^%&%&^%^&%^&^&%");
System.out.println(linearOrders);
System.out.println(p.toString());
			//Check gamma against linear extensions
			if (prLinearExtensionsCheck(linearOrders, p, suppressErrors)) {
				
				return p;
			}	
		}
		
		return null;
	}

	/**
	 * Takes in a List of linear orders and returns a List of Posets that make up an optimal Poset Cover with the predicate Kite.
	 * 
	 * @param linearOrders List of linearOrders, represented as List<ArrayList<T>>
	 * @return a list of Posets that makes up an optimal Poset Cover with the predicate Kite.
	 * 			Represented as List<Poset<T>>.
	 */
	@SuppressWarnings("unchecked")
	public static <T extends Comparable<T>> List<Poset<T>> generatingKitePosetCover(List<ArrayList<T>> linearOrders) {
		
		AdjacencyMatrix<LinearOrderVertex<T>, PosetEdge<LinearOrderVertex<T>, T>> matrix = new AdjacencyMatrix<LinearOrderVertex<T>, PosetEdge<LinearOrderVertex<T>, T>>(linearOrders.get(0).size());
		List<Poset<T>> posetCover = new ArrayList<Poset<T>>();
		
		//m = |linearOrders|
		//n = |linearOrders[0]|
		
		//O(m)
		//Add all linear orders to the graph
		for (ArrayList<T> linearOrder : linearOrders) {
			
			//matrix.addVertex(new LinearOrderVertex<T>(linearOrder));
			matrix.addVertex(new LinearOrderVertex<T>(linearOrder));
		}
		
		PosetEdge<LinearOrderVertex<T>, T> posetEdge;
		//O(m^3n^2)
		//Iterate over all possible vertex combinations
		for (int i = 0; i < matrix.getCapacity(); i++) {
			
			//O(m)
			for (int j = 0; j < matrix.getCapacity(); j++) {
				
				//If there are vertices for these....and the orders aren't the same
				if (i != j && matrix.getVertex(i) != null && matrix.getVertex(j) != null) {
				
					//If there is a generating poset for the two linear orders
					//O(mn^2)
					posetEdge = new PosetEdge<LinearOrderVertex<T>, T>(matrix.getVertex(i), matrix.getVertex(j));
					if (posetEdge.getGeneratingPoset() != null) {
						
						matrix.addEdge(i, j, posetEdge);
					}
				}
			}
		}

		//O(m^4)
		//Take the maximum matching
		AdjacencyMatrix<LinearOrderVertex<T>, PosetEdge<LinearOrderVertex<T>, T>> matchedGraph = MyEdmondsMatching.maximumMatching(matrix);

		//O(m^2) (because adjacency matrix implementation)
		//Get all of the edges from the maxmimum matching
		for (Edge<LinearOrderVertex<T>> e : matchedGraph.getEdges()) {
			
			posetEdge = (PosetEdge<LinearOrderVertex<T>, T>) e;
			
			//If the edge is a PosetEdge and it is not already in the PosetCover
			if (e instanceof PosetEdge<?, ?> && !posetCover.contains(posetEdge.getGeneratingPoset())) {
				
				posetCover.add(posetEdge.getGeneratingPoset());
			}
		}
		
		//O(m)
		//Get all the vertices with no edges from the maximum matching
		for (LinearOrderVertex<T> v : matchedGraph.getVertices()) {
			
			//If the vertex has no edges connected to it
			if (matchedGraph.getEdgesFrom(v).isEmpty() && matchedGraph.getEdgesTo(v).isEmpty()) {
	
				Poset<T> linearOrderPoset = new Poset<T>(v.getLinearOrder());
				
				//If the poset isn't already in the cover
				if (!posetCover.contains(linearOrderPoset)) {
					
					
					posetCover.add(linearOrderPoset);	
				}
			}
		}
		
		return posetCover;
	}
	
	/**
	 * Takes in a Poset and a list of linear orders parsed from the Pruesse and Ruskey program, so the linear orders are strings, and maps the values stored in
	 * string values to the corresponding string values depending on the curMapping contained in the poset object.
	 * 
	 * @param poset The Poset containing the current mapping to apply to the parsedLinearOrders.
	 * @param parsedLinearOrders the linear orders parsed from the Pruesse & Ruskey program output to apply the mapping to.
	 * @param suppressErrors boolean flag indicating whether error messages to stdout should be suppressed. True to suppress, false otherwise.
	 * @return A list of linear orders that reflect the mapping in poset.
	 */
	public static <T extends Comparable<T>> ArrayList<ArrayList<String>> mapParsedPruesseRuskey(Poset<T> poset, ArrayList<ArrayList<String>> parsedLinearOrders, boolean suppressErrors) {
		
		ArrayList<ArrayList<String>> mappedParsedLinearOrders = new ArrayList<ArrayList<String>>();
		ArrayList<String> mappedParsedLinearOrder;
		Map<Integer, Integer> mapping = poset.getCurMapping();
		
		for (ArrayList<String> parsedLinearOrder : parsedLinearOrders) {
			
			mappedParsedLinearOrder = new ArrayList<String>();
			for (int i = 0; i < parsedLinearOrder.size(); i++) {
				
				//Map the value in the parsed linear order to its corresponding element in the poset, making necessary conversions
				String parsedLinearOrderElement = parsedLinearOrder.get(i);
				Integer mapped = mapping.get(Integer.parseInt(parsedLinearOrderElement));
				String strVertex = String.valueOf(poset.getVertex(mapped));
				mappedParsedLinearOrder.add(strVertex);
			}
			mappedParsedLinearOrders.add(mappedParsedLinearOrder);
		}
		
		return mappedParsedLinearOrders;
	}
	
	/**
	 * Writes the passed in poset to TempPosetFile and runs Pruesse & Ruskey's algorithm on it.
	 * 
	 * @param linearOrders a list of linear orders.
	 * @param poset a poset.
	 * @param suppressErrors boolean falg indicating whether to suppressError output to stdout.
	 * 
	 * @return true if the poset produces the linear orders from its linear extensions.
	 */
	public static <T extends Comparable<T>> boolean prLinearExtensionsCheck(List<ArrayList<T>> linearOrders, Poset<T> poset, boolean suppressErrors) {

		//Run the pruesse Ruskey program
		ArrayList<ArrayList<String>> parsedLinearOrders = runPruesseRuskey(poset, linearOrders.get(0).size(), "PruesseRuskeyLinearExtensionsCheckPosetFile");

		parsedLinearOrders = mapParsedPruesseRuskey(poset, parsedLinearOrders, suppressErrors);
		
		//Compare linearOrder size
		if (linearOrders.size() != parsedLinearOrders.size()) {
		
			if (!suppressErrors) {
				System.out.println("\n\nPassed linear orders:");
				System.out.println(linearOrders.toString());
				System.out.println("Parsed linear orders:");
				System.out.println(parsedLinearOrders.toString());
				System.out.println("The Poset PR rep is:\n" + poset.pruesseRuskeyString());
				System.out.println("Linear orders counts differ in size....");
				System.out.println("Poset passed was:\n" + poset.toString());
				System.out.println("Cover edges in poset are:\n" + poset.printCoverEdges() + "\n\n\n");
			}
			return false;
		}
		
		//Sort both lists of linear orders--------------------------------
		//Sort linearOrders, (holding T type)
		Collections.sort(linearOrders, new Comparator<ArrayList<T>>() {

			@Override
			public int compare(ArrayList<T> o1, ArrayList<T> o2) {
				
				for (int i = 0; i < o1.size(); i++) {
					
					if (o1.get(i).compareTo(o2.get(i)) > 0) {
						
						return 1;
					}
					else if (o1.get(i).compareTo(o2.get(i)) < 0) {
						
						return -1;
					}
				}
				
				return 0;
			}
		});
		//sort parsedLinearOrders (holding Strings)
		Collections.sort(parsedLinearOrders, new Comparator<ArrayList<String>>() {

			@Override
			public int compare(ArrayList<String> o1, ArrayList<String> o2) {
				
				for (int i = 0; i < o1.size(); i++) {
					
					if (o1.get(i).compareTo(o2.get(i)) > 0) {
						
						return 1;
					}
					else if (o1.get(i).compareTo(o2.get(i)) < 0) {
						
						return -1;
					}
				}
				
				return 0;
			}
		});
		
		//Iterate over linear orders
		ArrayList<T> passedLinearOrder;
		ArrayList<String> parsedLinearOrder;
		for (int i = 0; i < linearOrders.size(); i++) {
			
			passedLinearOrder = linearOrders.get(i);
			parsedLinearOrder = parsedLinearOrders.get(i);
			
			//Check sizes match
			if (passedLinearOrder.size() != parsedLinearOrder.size()) {
				
				if (!suppressErrors) {
					System.out.println("The " + i + "th linear order differed in size");
				}
				return false;
			}
			
			//Iterate over each element of the current linear order
			for (int j = 0; j < passedLinearOrder.size(); j++) {
				
				if (!parsedLinearOrder.get(j).equals(passedLinearOrder.get(j).toString())) {
					
					if (!suppressErrors) {
						System.out.println("The linear orders were not the same....");
						System.out.println("parsedLinearOrder:\n" + parsedLinearOrder + "\npassedLinearOrder:\n" + passedLinearOrder);
					}
					return false;
				}
			}
		}

		return true;
	}
	
	/**
	 * Runs the Pruesse & Ruskey C program. Parses the output from it,
	 * and stores it in an ArrayList<ArrayList<Integer>> 
	 * 
	 * @param poset the poset to generate linear orders from.
	 * @param orderLength the expected length of the linear orders.
	 * @param filename the filename to save the poset's representation to.
	 * @return all of the linear orders produced from running the pruesse & ruskey algorithm.
	 */
	public static <T extends Comparable<T>> ArrayList<ArrayList<String>> runPruesseRuskey(Poset<T> poset, int orderLength, String filename) {
		
		ArrayList<ArrayList<String>> parsedLinearOrders = null;
		
		if (writePosetToFile(poset, filename)) {
		
			//Read from file, take as arg
			Runtime rt = Runtime.getRuntime();
			String[] args = new String[3];
			args[0] = "PruessseRuskeyLinearExtensions";
			args[1] = "-p";
			args[2] = filename;
			
			
			Process pr;
			try {
				
				pr = rt.exec(args);

				InputStream is = pr.getInputStream();
				BufferedReader br = null;
				StringBuilder sb = new StringBuilder();
		 
				String line;
				try {
					br = new BufferedReader(new InputStreamReader(is));
					while ((line = br.readLine()) != null) {
						sb.append(line);
					}
				} 
				catch (IOException e) {
					e.printStackTrace();
				} 
				finally {
					if (br != null) {	
						try {
							br.close();
						} 
						catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				pr.destroy();
		 
				String readString = sb.toString().trim();

				char[] readChars = readString.toCharArray();
				int begIndex = 0;
				
				ArrayList<String> linearOrder = new ArrayList<String>();
				parsedLinearOrders = new ArrayList<ArrayList<String>>();
				
				//Parse output text into linear orders
				for (int i = 0; i < readString.length(); i++) {
		
					//Add linear order to the list of linear orders
					if ((i + 1) == readString.length() 
							|| (linearOrder.size() + 1 == orderLength && readChars[i] == ' ')) {
		
						//For case where we're at the end
						if (i + 1 == readString.length()) {
						
							linearOrder.add(readString.substring(begIndex, i + 1));
						}
						//Normal case
						else {
							
							linearOrder.add(readString.substring(begIndex, i));
						}
						parsedLinearOrders.add(linearOrder);
						begIndex = i + 1;
						
						linearOrder = new ArrayList<String>();
					}
					//Add to the current linear order
					else if (readChars[i] == ' ') {
										
						//Add data
						linearOrder.add(readString.substring(begIndex, i));
						begIndex = i + 1;
					}
				}
			} 
			catch (IOException e1) {
				e1.printStackTrace();
			}
		}
System.out.println("parsedLinearOrders == " + parsedLinearOrders);
		return parsedLinearOrders;
	}
	
	/**
	 * Writes the passed in poset to the filename specified.
	 * 
	 * @param poset the Poset<T> to write to file.
	 * @param filename the filename
	 * @return True if successful, false otherwise.
	 */
	public static <T extends Comparable<T>> boolean writePosetToFile(Poset<T> poset, String filename) {
		
		//Write poset to temp file
		PrintWriter out;
		try {
			out = new PrintWriter(new FileWriter(filename));
			out.print(poset.pruesseRuskeyString());
			out.close();
			return true;
		}
		catch (IOException e) {
			e.printStackTrace();
			return false;
		}
	}
	
	/**
	 * Takes an ArrayList of ArrayLists of Strings that represent linear orders parsed from the Pruesse & Ruskey program.
	 * Returns an ArrayList of ArrayLists of Integers.
	 * 
	 * NOTE: It is assumed that the passed Strings are Strings of numbers.
	 * 
	 * @param parsedLinearOrders ArrayList<ArrayList<String>> where each String holds a number in String form.
	 * @return ArrayList<ArrayList<Integer>> where each Integer corresponds to a translated String.
	 */
	public static <T extends Comparable<T>> ArrayList<ArrayList<Integer>> parsedPruesseRuskeyToInteger(ArrayList<ArrayList<String>> parsedLinearOrders) {
		
		//Parse Pruess & Ruskey results into Integer ArrayLists instead of String ArrayLists
		ArrayList<ArrayList<Integer>> numericalLinearOrders = new ArrayList<ArrayList<Integer>>();
		ArrayList<Integer> numericalLinearOrder;
		for (ArrayList<String> parsedLinearOrder : parsedLinearOrders) {
		
			numericalLinearOrder = new ArrayList<Integer>();
			for (String parsedElement : parsedLinearOrder) {
				
				Integer numericalElement = Integer.valueOf(parsedElement);
				numericalLinearOrder.add(numericalElement);
			}
			numericalLinearOrders.add(numericalLinearOrder);
		}
		
		return numericalLinearOrders;
	}
}